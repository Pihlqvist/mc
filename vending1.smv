MODULE main
VAR
  choice:  boolean;
  payment: boolean;
  acc_payment: boolean;
  n_items: 0..3; -- initiated a numerical value
  state:   { ready, expect_payment, dispense_item };

ASSIGN
  init (state) := ready;
  next (state) := case
		    state = ready          & choice:  expect_payment;
		    state = expect_payment & acc_payment: dispense_item;
		    state = expect_payment & !choice: ready;
		    state = dispense_item:	      ready;
		    TRUE:                             state;
  esac;

  init (acc_payment) := FALSE;
  next (acc_payment) := (state = expect_payment & payment & choice & n_items > 0);
  -- Can't acc_payment if there is no item to choose from

  next (n_items) := case
    release_item & n_items > 0 : n_items - 1; -- had to add n_items > 0 here as well for it to compile.
    -- We thought it would be enough to have this conditional check once, but apparently not
    TRUE: n_items;
  esac;

DEFINE
  release_item := (state = dispense_item);

LTLSPEC
  G(acc_payment -> F release_item);

-- specification  G (acc_payment ->  F release_item)  is false
-- as demonstrated by the following execution sequence
-- Trace Description: LTL Counterexample
-- Trace Type: Counterexample
--  -> State: 1.1 <-
--    choice = FALSE
--    payment = FALSE
--    acc_payment = FALSE // Initiated as false
--    state = ready // Initiated as true
--    release_item = FALSE // False because state != dispense_item
--  -> State: 1.2 <-
--    choice = TRUE // Choice is toggled, nothing happens
--  -> State: 1.3 <-
--    choice = FALSE // is toggled again back to false.
--    payment = TRUE // is toggled to TRUE. Costumer has
--    state = expect_payment // Because choice == True in 1.2 and state == ready,
--          we continue to state expect_payment
--  -> State: 1.4 <-
--    payment = FALSE // toggled to false
--    acc_payment = TRUE // set to true because state == expect_payment from 1.3 and payment = TRUE from 1.3
--    state = ready //Because choice == false from 1.3 and state == expect_payment from 1.3, we are placed in ready.
--  -- Loop starts here
--  -> State: 1.5 <-
--  -> State: 1.6 <-
--    acc_payment = FALSE
-- // Because acc_payment was never affected by having made a choice or not we could toggle the variables to never step into
-- dispense_item state. Adding & choice in acc_payment solved the counterexamples.
